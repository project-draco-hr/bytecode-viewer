{
  try {
    treeRoot.removeAllChildren();
    for (    final Entry<String,ClassNode> entry : BytecodeViewer.loadedClasses.entrySet()) {
      String name=entry.getKey();
      final String[] spl=name.split("/");
      if (spl.length < 2) {
        treeRoot.add(new MyTreeNode(name + ".class"));
      }
 else {
        MyTreeNode parent=treeRoot;
        for (int i1=0; i1 < spl.length; i1++) {
          String s=spl[i1];
          MyTreeNode child=null;
          for (int i=0; i < parent.getChildCount(); i++) {
            if (((MyTreeNode)parent.getChildAt(i)).getUserObject().equals(s)) {
              child=(MyTreeNode)parent.getChildAt(i);
              break;
            }
          }
          if (child == null) {
            if (i1 == spl.length - 1)             child=new MyTreeNode(s + ".class");
 else             child=new MyTreeNode(s);
            parent.add(child);
          }
          parent=child;
        }
      }
    }
    for (    final Entry<String,byte[]> entry : BytecodeViewer.loadedResources.entrySet()) {
      String name=entry.getKey();
      final String[] spl=name.split("/");
      if (spl.length < 2) {
        treeRoot.add(new MyTreeNode(name));
      }
 else {
        MyTreeNode parent=treeRoot;
        for (        final String s : spl) {
          MyTreeNode child=null;
          for (int i=0; i < parent.getChildCount(); i++) {
            if (((MyTreeNode)parent.getChildAt(i)).getUserObject().equals(s)) {
              child=(MyTreeNode)parent.getChildAt(i);
              break;
            }
          }
          if (child == null) {
            child=new MyTreeNode(s);
            parent.add(child);
          }
          parent=child;
        }
      }
    }
    treeRoot.sort();
    tree.expandPath(new TreePath(tree.getModel().getRoot()));
    tree.updateUI();
  }
 catch (  java.util.ConcurrentModificationException e) {
  }
}
