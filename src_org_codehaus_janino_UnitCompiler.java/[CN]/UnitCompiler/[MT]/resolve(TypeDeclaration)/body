{
  final AbstractTypeDeclaration atd=(AbstractTypeDeclaration)td;
  if (atd.resolvedType == null)   atd.resolvedType=new IClass(){
    @Override protected IClass.IMethod[] getDeclaredIMethods2(){
      IClass.IMethod[] res=new IClass.IMethod[atd.getMethodDeclarations().size()];
      int i=0;
      for (      MethodDeclarator md : atd.getMethodDeclarations()) {
        res[i++]=UnitCompiler.this.toIMethod(md);
      }
      return res;
    }
    private IClass[] declaredClasses;
    @Override protected IClass[] getDeclaredIClasses2(){
      if (this.declaredClasses == null) {
        Collection<MemberTypeDeclaration> mtds=td.getMemberTypeDeclarations();
        IClass[] mts=new IClass[mtds.size()];
        int i=0;
        for (        MemberTypeDeclaration mtd : mtds) {
          mts[i++]=UnitCompiler.this.resolve(mtd);
        }
        this.declaredClasses=mts;
      }
      return this.declaredClasses;
    }
    @Override protected IClass getDeclaringIClass2(){
      Scope s=atd;
      for (; !(s instanceof TypeBodyDeclaration); s=s.getEnclosingScope()) {
        if (s instanceof CompilationUnit)         return null;
      }
      return UnitCompiler.this.resolve((AbstractTypeDeclaration)s.getEnclosingScope());
    }
    @Override protected IClass getOuterIClass2(){
      AbstractTypeDeclaration oc=(AbstractTypeDeclaration)UnitCompiler.getOuterClass(atd);
      if (oc == null)       return null;
      return UnitCompiler.this.resolve(oc);
    }
    @Override protected final String getDescriptor2(){
      return Descriptor.fromClassName(atd.getClassName());
    }
    @Override public boolean isArray(){
      return false;
    }
    @Override protected IClass getComponentType2(){
      throw new JaninoRuntimeException("SNO: Non-array type has no component type");
    }
    @Override public boolean isPrimitive(){
      return false;
    }
    @Override public boolean isPrimitiveNumeric(){
      return false;
    }
    @Override protected IConstructor[] getDeclaredIConstructors2(){
      if (atd instanceof ClassDeclaration) {
        ConstructorDeclarator[] cs=((ClassDeclaration)atd).getConstructors();
        IClass.IConstructor[] res=new IClass.IConstructor[cs.length];
        for (int i=0; i < cs.length; ++i)         res[i]=UnitCompiler.this.toIConstructor(cs[i]);
        return res;
      }
      return new IClass.IConstructor[0];
    }
    @Override protected IField[] getDeclaredIFields2(){
      if (atd instanceof ClassDeclaration) {
        ClassDeclaration cd=(ClassDeclaration)atd;
        List<IClass.IField> l=new ArrayList();
        for (        BlockStatement vdoi : cd.variableDeclaratorsAndInitializers) {
          if (vdoi instanceof FieldDeclaration) {
            FieldDeclaration fd=(FieldDeclaration)vdoi;
            IClass.IField[] flds=UnitCompiler.this.getIFields(fd);
            for (            IField fld : flds)             l.add(fld);
          }
        }
        return (IClass.IField[])l.toArray(new IClass.IField[l.size()]);
      }
 else       if (atd instanceof InterfaceDeclaration) {
        InterfaceDeclaration id=(InterfaceDeclaration)atd;
        List<IClass.IField> l=new ArrayList();
        for (        BlockStatement bs : id.constantDeclarations) {
          if (bs instanceof FieldDeclaration) {
            FieldDeclaration fd=(FieldDeclaration)bs;
            IClass.IField[] flds=UnitCompiler.this.getIFields(fd);
            for (            IField fld : flds)             l.add(fld);
          }
        }
        return (IClass.IField[])l.toArray(new IClass.IField[l.size()]);
      }
 else {
        throw new JaninoRuntimeException("SNO: AbstractTypeDeclaration is neither ClassDeclaration nor InterfaceDeclaration");
      }
    }
    @Override public IField[] getSyntheticIFields(){
      if (atd instanceof ClassDeclaration) {
        Collection<IClass.IField> c=((ClassDeclaration)atd).syntheticFields.values();
        return (IField[])c.toArray(new IField[c.size()]);
      }
      return new IField[0];
    }
    @Override protected IClass getSuperclass2() throws CompileException {
      if (atd instanceof AnonymousClassDeclaration) {
        IClass bt=UnitCompiler.this.getType(((AnonymousClassDeclaration)atd).baseType);
        return bt.isInterface() ? UnitCompiler.this.iClassLoader.TYPE_java_lang_Object : bt;
      }
      if (atd instanceof NamedClassDeclaration) {
        NamedClassDeclaration ncd=(NamedClassDeclaration)atd;
        if (ncd.optionalExtendedType == null)         return UnitCompiler.this.iClassLoader.TYPE_java_lang_Object;
        IClass superclass=UnitCompiler.this.getType(ncd.optionalExtendedType);
        if (superclass.isInterface()) {
          UnitCompiler.this.compileError("\"" + superclass.toString() + "\" is an interface; classes can only extend a class",td.getLocation());
        }
        return superclass;
      }
      return null;
    }
    @Override public Access getAccess(){
      return UnitCompiler.modifiers2Access(atd.getModifierFlags());
    }
    @Override public boolean isFinal(){
      return Mod.isFinal(atd.getModifierFlags());
    }
    @Override protected IClass[] getInterfaces2() throws CompileException {
      if (atd instanceof AnonymousClassDeclaration) {
        IClass bt=UnitCompiler.this.getType(((AnonymousClassDeclaration)atd).baseType);
        return bt.isInterface() ? new IClass[]{bt} : new IClass[0];
      }
 else       if (atd instanceof NamedClassDeclaration) {
        NamedClassDeclaration ncd=(NamedClassDeclaration)atd;
        IClass[] res=new IClass[ncd.implementedTypes.length];
        for (int i=0; i < res.length; ++i) {
          res[i]=UnitCompiler.this.getType(ncd.implementedTypes[i]);
          if (!res[i].isInterface()) {
            UnitCompiler.this.compileError(("\"" + res[i].toString() + "\" is not an interface; classes can only implement interfaces"),td.getLocation());
          }
        }
        return res;
      }
 else       if (atd instanceof InterfaceDeclaration) {
        InterfaceDeclaration id=(InterfaceDeclaration)atd;
        IClass[] res=new IClass[id.extendedTypes.length];
        for (int i=0; i < res.length; ++i) {
          res[i]=UnitCompiler.this.getType(id.extendedTypes[i]);
          if (!res[i].isInterface()) {
            UnitCompiler.this.compileError(("\"" + res[i].toString() + "\" is not an interface; interfaces can only extend interfaces"),td.getLocation());
          }
        }
        return res;
      }
 else {
        throw new JaninoRuntimeException("SNO: AbstractTypeDeclaration is neither ClassDeclaration nor InterfaceDeclaration");
      }
    }
    @Override public boolean isAbstract(){
      return atd instanceof InterfaceDeclaration || Mod.isAbstract(atd.getModifierFlags());
    }
    @Override public boolean isInterface(){
      return atd instanceof InterfaceDeclaration;
    }
  }
;
  return atd.resolvedType;
}
