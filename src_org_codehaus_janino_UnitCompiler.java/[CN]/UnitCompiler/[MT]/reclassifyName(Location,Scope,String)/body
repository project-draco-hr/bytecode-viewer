{
  TypeBodyDeclaration scopeTbd=null;
  AbstractTypeDeclaration scopeTypeDeclaration=null;
  CompilationUnit scopeCompilationUnit;
{
    Scope s=scope;
    while ((s instanceof BlockStatement || s instanceof CatchClause) && !(s instanceof TypeBodyDeclaration))     s=s.getEnclosingScope();
    if (s instanceof TypeBodyDeclaration) {
      scopeTbd=(TypeBodyDeclaration)s;
      s=s.getEnclosingScope();
    }
    if (s instanceof TypeDeclaration) {
      scopeTypeDeclaration=(AbstractTypeDeclaration)s;
      s=s.getEnclosingScope();
    }
    while (!(s instanceof CompilationUnit))     s=s.getEnclosingScope();
    scopeCompilationUnit=(CompilationUnit)s;
  }
{
    Scope s=scope;
    if (s instanceof BlockStatement) {
      BlockStatement bs=(BlockStatement)s;
      LocalVariable lv=bs.findLocalVariable(identifier);
      if (lv != null) {
        LocalVariableAccess lva=new LocalVariableAccess(location,lv);
        lva.setEnclosingBlockStatement(bs);
        return lva;
      }
      s=s.getEnclosingScope();
    }
    while (s instanceof BlockStatement || s instanceof CatchClause)     s=s.getEnclosingScope();
    if (s instanceof FunctionDeclarator) {
      s=s.getEnclosingScope();
    }
    if (s instanceof InnerClassDeclaration) {
      InnerClassDeclaration icd=(InnerClassDeclaration)s;
      s=s.getEnclosingScope();
      if (s instanceof AnonymousClassDeclaration) {
        s=s.getEnclosingScope();
      }
 else       if (s instanceof FieldDeclaration) {
        s=s.getEnclosingScope().getEnclosingScope();
      }
      while (s instanceof BlockStatement) {
        LocalVariable lv=((BlockStatement)s).findLocalVariable(identifier);
        if (lv != null) {
          if (!lv.finaL) {
            this.compileError("Cannot access non-final local variable \"" + identifier + "\" from inner class");
          }
          final IClass lvType=lv.type;
          IClass.IField iField=new SimpleIField(this.resolve(icd),"val$" + identifier,lvType);
          icd.defineSyntheticField(iField);
          FieldAccess fa=new FieldAccess(location,new QualifiedThisReference(location,new SimpleType(location,this.resolve(icd))),iField);
          fa.setEnclosingBlockStatement((BlockStatement)scope);
          return fa;
        }
        s=s.getEnclosingScope();
        while (s instanceof BlockStatement)         s=s.getEnclosingScope();
        if (!(s instanceof FunctionDeclarator))         break;
        s=s.getEnclosingScope();
        if (!(s instanceof InnerClassDeclaration))         break;
        icd=(InnerClassDeclaration)s;
        s=s.getEnclosingScope();
      }
    }
  }
  BlockStatement enclosingBlockStatement=null;
  for (Scope s=scope; !(s instanceof CompilationUnit); s=s.getEnclosingScope()) {
    if (s instanceof BlockStatement && enclosingBlockStatement == null) {
      enclosingBlockStatement=(BlockStatement)s;
    }
    if (s instanceof TypeDeclaration) {
      final AbstractTypeDeclaration enclosingTypeDecl=(AbstractTypeDeclaration)s;
      final IClass etd=this.resolve(enclosingTypeDecl);
      final IClass.IField f=this.findIField(etd,identifier,location);
      if (f != null) {
        if (f.isStatic()) {
          this.warning("IASF",("Implicit access to static field \"" + identifier + "\" of declaring class (better write \""+ f.getDeclaringIClass()+ '.'+ f.getName()+ "\")"),location);
        }
 else         if (f.getDeclaringIClass() == etd) {
          this.warning("IANSF",("Implicit access to non-static field \"" + identifier + "\" of declaring class (better write \"this."+ f.getName()+ "\")"),location);
        }
 else {
          this.warning("IANSFEI",("Implicit access to non-static field \"" + identifier + "\" of enclosing instance (better write \""+ f.getDeclaringIClass()+ ".this."+ f.getName()+ "\")"),location);
        }
        SimpleType ct=new SimpleType(scopeTypeDeclaration.getLocation(),etd);
        Atom lhs;
        if (scopeTbd.isStatic()) {
          lhs=ct;
        }
 else {
          if (f.isStatic()) {
            lhs=ct;
          }
 else {
            lhs=new QualifiedThisReference(location,ct);
          }
        }
        Rvalue res=new FieldAccess(location,lhs,f);
        res.setEnclosingBlockStatement(enclosingBlockStatement);
        return res;
      }
    }
  }
{
    List<Object> l=(List)this.singleStaticImports.get(identifier);
    if (l != null) {
      for (      Object o : l) {
        if (o instanceof IField) {
          FieldAccess fieldAccess=new FieldAccess(location,new SimpleType(location,((IField)o).getDeclaringIClass()),(IField)o);
          fieldAccess.setEnclosingBlockStatement(enclosingBlockStatement);
          return fieldAccess;
        }
      }
    }
  }
{
    IField importedField=null;
    for (    IClass iClass : this.staticImportsOnDemand) {
      IField f=iClass.getDeclaredIField(identifier);
      if (f != null) {
        if (!this.isAccessible(f,enclosingBlockStatement))         continue;
        if (importedField != null) {
          this.compileError("Ambiguous static field import: \"" + importedField.toString() + "\" vs. \""+ f.toString()+ "\"");
        }
        importedField=f;
      }
    }
    if (importedField != null) {
      if (!importedField.isStatic())       this.compileError("Cannot static-import non-static field");
      FieldAccess fieldAccess=new FieldAccess(location,new SimpleType(location,importedField.getDeclaringIClass()),importedField);
      fieldAccess.setEnclosingBlockStatement(enclosingBlockStatement);
      return fieldAccess;
    }
  }
  if ("java".equals(identifier))   return new Package(location,identifier);
{
    IClass unnamedPackageType=this.findTypeByName(location,identifier);
    if (unnamedPackageType != null)     return new SimpleType(location,unnamedPackageType);
  }
{
    LocalClassDeclaration lcd=UnitCompiler.findLocalClassDeclaration(scope,identifier);
    if (lcd != null)     return new SimpleType(location,this.resolve(lcd));
  }
  if (scopeTypeDeclaration != null) {
    IClass memberType=this.findMemberType(this.resolve(scopeTypeDeclaration),identifier,location);
    if (memberType != null)     return new SimpleType(location,memberType);
  }
{
    IClass iClass=this.importSingleType(identifier,location);
    if (iClass != null)     return new SimpleType(location,iClass);
  }
{
    PackageMemberTypeDeclaration pmtd=scopeCompilationUnit.getPackageMemberTypeDeclaration(identifier);
    if (pmtd != null)     return new SimpleType(location,this.resolve(pmtd));
  }
{
    String className=(scopeCompilationUnit.optionalPackageDeclaration == null ? identifier : scopeCompilationUnit.optionalPackageDeclaration.packageName + '.' + identifier);
    IClass result=this.findTypeByName(location,className);
    if (result != null)     return new SimpleType(location,result);
  }
{
    IClass importedClass=this.importTypeOnDemand(identifier,location);
    if (importedClass != null) {
      return new SimpleType(location,importedClass);
    }
  }
{
    List<Object> l=(List)this.singleStaticImports.get(identifier);
    if (l != null) {
      for (      Object o : l) {
        if (o instanceof IClass)         return new SimpleType(null,(IClass)o);
      }
    }
  }
{
    IClass importedType=null;
    for (    IClass ic : this.staticImportsOnDemand) {
      IClass[] memberTypes=ic.getDeclaredIClasses();
      for (      IClass memberType : memberTypes) {
        if (!this.isAccessible(memberType,scope))         continue;
        if (memberType.getDescriptor().endsWith('$' + identifier + ';')) {
          if (importedType != null) {
            this.compileError("Ambiguous static type import: \"" + importedType.toString() + "\" vs. \""+ memberType.toString()+ "\"");
          }
          importedType=memberType;
        }
      }
    }
    if (importedType != null)     return new SimpleType(null,importedType);
  }
  return new Package(location,identifier);
}
