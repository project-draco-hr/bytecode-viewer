{
  final Location loc=cl.getLocation();
  final IClassLoader icl=this.iClassLoader;
  IClass iClass=this.getType(cl.type);
  if (iClass.isPrimitive()) {
    this.writeOpcode(cl,Opcode.GETSTATIC);
    String wrapperClassDescriptor=(iClass == IClass.VOID ? "Ljava/lang/Void;" : iClass == IClass.BYTE ? "Ljava/lang/Byte;" : iClass == IClass.CHAR ? "Ljava/lang/Character;" : iClass == IClass.DOUBLE ? "Ljava/lang/Double;" : iClass == IClass.FLOAT ? "Ljava/lang/Float;" : iClass == IClass.INT ? "Ljava/lang/Integer;" : iClass == IClass.LONG ? "Ljava/lang/Long;" : iClass == IClass.SHORT ? "Ljava/lang/Short;" : iClass == IClass.BOOLEAN ? "Ljava/lang/Boolean;" : null);
    if (wrapperClassDescriptor == null) {
      throw new JaninoRuntimeException("SNO: Unidentifiable primitive type \"" + iClass + "\"");
    }
    this.writeConstantFieldrefInfo(wrapperClassDescriptor,"TYPE","Ljava/lang/Class;");
    return icl.TYPE_java_lang_Class;
  }
  TypeDeclaration declaringType;
  for (Scope s=cl.getEnclosingBlockStatement(); ; s=s.getEnclosingScope()) {
    if (s instanceof TypeDeclaration) {
      declaringType=(AbstractTypeDeclaration)s;
      break;
    }
  }
  if (declaringType.getMethodDeclaration("class$") == null)   this.declareClassDollarMethod(cl);
  List<? extends BlockStatement> statics;
  if (declaringType instanceof ClassDeclaration) {
    statics=((ClassDeclaration)declaringType).variableDeclaratorsAndInitializers;
  }
 else   if (declaringType instanceof InterfaceDeclaration) {
    statics=((InterfaceDeclaration)declaringType).constantDeclarations;
  }
 else {
    throw new JaninoRuntimeException("SNO: AbstractTypeDeclaration is neither ClassDeclaration nor InterfaceDeclaration");
  }
  String className=Descriptor.toClassName(iClass.getDescriptor());
  String classDollarFieldName;
{
    if (className.startsWith("[")) {
      classDollarFieldName="array" + className.replace('.','$').replace('[','$');
      if (classDollarFieldName.endsWith(";")) {
        classDollarFieldName=classDollarFieldName.substring(0,classDollarFieldName.length() - 1);
      }
    }
 else {
      classDollarFieldName="class$" + className.replace('.','$');
    }
  }
  ADD_CLASS_DOLLAR_FIELD: {
    for (    BlockStatement bs : statics) {
      if (!((TypeBodyDeclaration)bs).isStatic())       continue;
      if (bs instanceof FieldDeclaration) {
        for (        VariableDeclarator vd : ((FieldDeclaration)bs).variableDeclarators) {
          if (vd.name.equals(classDollarFieldName)) {
            break ADD_CLASS_DOLLAR_FIELD;
          }
        }
      }
    }
    Type classType=new SimpleType(loc,icl.TYPE_java_lang_Class);
    FieldDeclaration fd=new FieldDeclaration(loc,null,new Modifiers(Mod.STATIC),classType,new VariableDeclarator[]{new VariableDeclarator(loc,classDollarFieldName,0,(Rvalue)null)});
    if (declaringType instanceof ClassDeclaration) {
      ((ClassDeclaration)declaringType).addFieldDeclaration(fd);
    }
 else     if (declaringType instanceof InterfaceDeclaration) {
      ((InterfaceDeclaration)declaringType).addConstantDeclaration(fd);
    }
 else {
      throw new JaninoRuntimeException("SNO: AbstractTypeDeclaration is neither ClassDeclaration nor InterfaceDeclaration");
    }
  }
  Type declaringClassOrInterfaceType=new SimpleType(loc,this.resolve(declaringType));
  Lvalue classDollarFieldAccess=new FieldAccessExpression(loc,declaringClassOrInterfaceType,classDollarFieldName);
  ConditionalExpression ce=new ConditionalExpression(loc,new BinaryOperation(loc,classDollarFieldAccess,"!=",new NullLiteral(loc,"null")),classDollarFieldAccess,new Assignment(loc,classDollarFieldAccess,"=",new MethodInvocation(loc,declaringClassOrInterfaceType,"class$",new Rvalue[]{new StringLiteral(loc,'"' + className + '"')})));
  ce.setEnclosingBlockStatement(cl.getEnclosingBlockStatement());
  return this.compileGet(ce);
}
