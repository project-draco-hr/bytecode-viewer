{
  IClass.IMethod iMethod;
  FIND_METHOD: {
    if (mi.optionalTarget == null) {
      for (Scope s=mi.getEnclosingBlockStatement(); !(s instanceof CompilationUnit); s=s.getEnclosingScope()) {
        if (s instanceof TypeDeclaration) {
          TypeDeclaration td=(TypeDeclaration)s;
          iMethod=this.findIMethod(this.resolve(td),mi);
          if (iMethod != null)           break FIND_METHOD;
        }
      }
    }
 else {
      iMethod=this.findIMethod(this.getType(mi.optionalTarget),mi);
      if (iMethod != null)       break FIND_METHOD;
    }
{
      List<Object> l=(List)this.singleStaticImports.get(mi.methodName);
      if (l != null) {
        iMethod=null;
        for (        Object o : l) {
          if (o instanceof IMethod) {
            IClass declaringIClass=((IMethod)o).getDeclaringIClass();
            IMethod im=this.findIMethod(declaringIClass,mi);
            if (im != null) {
              if (iMethod != null && iMethod != im) {
                this.compileError("Ambiguous static method import: \"" + iMethod.toString() + "\" vs. \""+ im.toString()+ "\"");
              }
              iMethod=im;
            }
          }
        }
        if (iMethod != null)         break FIND_METHOD;
      }
    }
    iMethod=null;
    for (    IClass iClass : this.staticImportsOnDemand) {
      IMethod im=this.findIMethod(iClass,mi);
      if (im != null) {
        if (iMethod != null) {
          this.compileError("Ambiguous static method import: \"" + iMethod.toString() + "\" vs. \""+ im.toString()+ "\"");
        }
        iMethod=im;
      }
    }
    if (iMethod != null)     break FIND_METHOD;
    this.compileError(("A method named \"" + mi.methodName + "\" is not declared in any enclosing class nor any supertype, nor through a static import"),mi.getLocation());
    return this.fakeIMethod(this.iClassLoader.TYPE_java_lang_Object,mi.methodName,mi.arguments);
  }
  this.checkThrownExceptions(mi,iMethod);
  return iMethod;
}
