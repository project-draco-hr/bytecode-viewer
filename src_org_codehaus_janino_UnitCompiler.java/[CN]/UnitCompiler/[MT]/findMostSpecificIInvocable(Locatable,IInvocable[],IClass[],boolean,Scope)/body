{
  if (UnitCompiler.DEBUG) {
    System.out.println("Argument types:");
    for (    IClass argumentType : argumentTypes)     System.out.println(argumentType);
  }
  List<IClass.IInvocable> applicableIInvocables=new ArrayList();
  List<IClass.IInvocable> varargApplicables=new ArrayList();
  NEXT_METHOD:   for (  IClass.IInvocable ii : iInvocables) {
    boolean argsNeedAdjust=false;
    if (!this.isAccessible(ii,contextScope))     continue;
    final IClass[] parameterTypes=ii.getParameterTypes();
    int formalParamCount=parameterTypes.length;
    int nUncheckedArg=argumentTypes.length;
    final boolean isVarargs=ii.isVarargs();
    VARARGS:     if (isVarargs) {
      formalParamCount--;
      final IClass lastParamType=parameterTypes[formalParamCount].getComponentType();
      final int lastActualArg=nUncheckedArg - 1;
      if (formalParamCount == lastActualArg && argumentTypes[lastActualArg].isArray() && this.isMethodInvocationConvertible(argumentTypes[lastActualArg].getComponentType(),lastParamType,boxingPermitted)) {
        nUncheckedArg--;
      }
 else {
        for (int idx=lastActualArg; idx >= formalParamCount; --idx) {
          if (!this.isMethodInvocationConvertible(argumentTypes[idx],lastParamType,boxingPermitted)) {
            formalParamCount++;
            break VARARGS;
          }
          nUncheckedArg--;
        }
        argsNeedAdjust=true;
      }
    }
    if (formalParamCount == nUncheckedArg) {
      for (int j=0; j < nUncheckedArg; ++j) {
        if (UnitCompiler.DEBUG)         System.out.println(parameterTypes[j] + " <=> " + argumentTypes[j]);
        if (!this.isMethodInvocationConvertible(argumentTypes[j],parameterTypes[j],boxingPermitted)) {
          continue NEXT_METHOD;
        }
      }
      if (UnitCompiler.DEBUG)       System.out.println("Applicable!");
      if (isVarargs) {
        ii.setArgsNeedAdjust(argsNeedAdjust);
        varargApplicables.add(ii);
      }
 else {
        applicableIInvocables.add(ii);
      }
    }
  }
  if (applicableIInvocables.size() == 1) {
    return (IClass.IInvocable)applicableIInvocables.get(0);
  }
  if (applicableIInvocables.size() == 0 && !varargApplicables.isEmpty()) {
    applicableIInvocables=varargApplicables;
    if (applicableIInvocables.size() == 1) {
      return (IClass.IInvocable)applicableIInvocables.get(0);
    }
  }
  if (applicableIInvocables.size() == 0)   return null;
  List<IClass.IInvocable> maximallySpecificIInvocables=new ArrayList();
  for (  IClass.IInvocable applicableIInvocable : applicableIInvocables) {
    int moreSpecific=0, lessSpecific=0;
    for (    IClass.IInvocable mostSpecificIInvocable : maximallySpecificIInvocables) {
      if (applicableIInvocable.isMoreSpecificThan(mostSpecificIInvocable)) {
        ++moreSpecific;
      }
 else       if (applicableIInvocable.isLessSpecificThan(mostSpecificIInvocable)) {
        ++lessSpecific;
      }
    }
    if (moreSpecific == maximallySpecificIInvocables.size()) {
      maximallySpecificIInvocables.clear();
      maximallySpecificIInvocables.add(applicableIInvocable);
    }
 else     if (lessSpecific < maximallySpecificIInvocables.size()) {
      maximallySpecificIInvocables.add(applicableIInvocable);
    }
 else {
      ;
    }
    if (UnitCompiler.DEBUG)     System.out.println("maximallySpecificIInvocables=" + maximallySpecificIInvocables);
  }
  if (maximallySpecificIInvocables.size() == 1)   return (IClass.IInvocable)maximallySpecificIInvocables.get(0);
  ONE_NON_ABSTRACT_INVOCABLE:   if (maximallySpecificIInvocables.size() > 1 && iInvocables[0] instanceof IClass.IMethod) {
    IClass.IMethod theNonAbstractMethod=null;
{
      Iterator<IClass.IInvocable> it=maximallySpecificIInvocables.iterator();
      IClass.IMethod m=(IClass.IMethod)it.next();
      final IClass[] parameterTypesOfFirstMethod=m.getParameterTypes();
      for (; ; ) {
        if (!m.isAbstract()) {
          if (theNonAbstractMethod == null) {
            theNonAbstractMethod=m;
          }
 else {
            IClass declaringIClass=m.getDeclaringIClass();
            IClass theNonAbstractMethodDeclaringIClass=theNonAbstractMethod.getDeclaringIClass();
            if (declaringIClass == theNonAbstractMethodDeclaringIClass) {
              if (m.getReturnType() == theNonAbstractMethod.getReturnType()) {
                throw new JaninoRuntimeException("Two non-abstract methods '" + m + "' have the same parameter types, "+ "declaring type and return type");
              }
 else               if (m.getReturnType().isAssignableFrom(theNonAbstractMethod.getReturnType())) {
                ;
              }
 else               if (theNonAbstractMethod.getReturnType().isAssignableFrom(m.getReturnType())) {
                theNonAbstractMethod=m;
              }
 else {
                throw new JaninoRuntimeException("Incompatible return types");
              }
            }
 else             if (declaringIClass.isAssignableFrom(theNonAbstractMethodDeclaringIClass)) {
              ;
            }
 else             if (theNonAbstractMethodDeclaringIClass.isAssignableFrom(declaringIClass)) {
              theNonAbstractMethod=m;
            }
 else {
              throw new JaninoRuntimeException("SNO: Types declaring '" + theNonAbstractMethod + "' are not assignable");
            }
          }
        }
        if (!it.hasNext())         break;
        m=(IClass.IMethod)it.next();
        IClass[] pts=m.getParameterTypes();
        for (int i=0; i < pts.length; ++i) {
          if (pts[i] != parameterTypesOfFirstMethod[i])           break ONE_NON_ABSTRACT_INVOCABLE;
        }
      }
    }
    if (theNonAbstractMethod != null)     return theNonAbstractMethod;
    Set<IClass> s=new HashSet();
{
      IClass[][] tes=new IClass[maximallySpecificIInvocables.size()][];
      Iterator<IClass.IInvocable> it=maximallySpecificIInvocables.iterator();
      for (int i=0; i < tes.length; ++i) {
        tes[i]=((IClass.IMethod)it.next()).getThrownExceptions();
      }
      for (int i=0; i < tes.length; ++i) {
        EACH_EXCEPTION:         for (        IClass te1 : tes[i]) {
          EACH_METHOD:           for (int k=0; k < tes.length; ++k) {
            if (k == i)             continue;
            for (            IClass te2 : tes[k]) {
              if (te2.isAssignableFrom(te1))               continue EACH_METHOD;
            }
            continue EACH_EXCEPTION;
          }
          s.add(te1);
        }
      }
    }
    final IClass.IMethod im=(IClass.IMethod)maximallySpecificIInvocables.get(0);
    final IClass[] tes=(IClass[])s.toArray(new IClass[s.size()]);
    return im.getDeclaringIClass().new IMethod(){
      @Override public String getName(){
        return im.getName();
      }
      @Override public IClass getReturnType() throws CompileException {
        return im.getReturnType();
      }
      @Override public boolean isAbstract(){
        return im.isAbstract();
      }
      @Override public boolean isStatic(){
        return im.isStatic();
      }
      @Override public Access getAccess(){
        return im.getAccess();
      }
      @Override public boolean isVarargs(){
        return im.isVarargs();
      }
      @Override public IClass[] getParameterTypes2() throws CompileException {
        return im.getParameterTypes();
      }
      @Override public IClass[] getThrownExceptions2(){
        return tes;
      }
      @Override public Annotation[] getAnnotations(){
        return im.getAnnotations();
      }
    }
;
  }
  if (!boxingPermitted)   return null;
{
    StringBuilder sb=new StringBuilder("Invocation of constructor/method with argument type(s) \"");
    for (int i=0; i < argumentTypes.length; ++i) {
      if (i > 0)       sb.append(", ");
      sb.append(Descriptor.toString(argumentTypes[i].getDescriptor()));
    }
    sb.append("\" is ambiguous: ");
    for (int i=0; i < maximallySpecificIInvocables.size(); ++i) {
      if (i > 0)       sb.append(" vs. ");
      sb.append("\"" + maximallySpecificIInvocables.get(i) + "\"");
    }
    this.compileError(sb.toString(),locatable.getLocation());
  }
  return iInvocables[0];
}
