{
  for (; ; ) {
    if (CodeContext.DEBUG)     System.out.println("Offset = " + offset + ", stack size = "+ stackSize);
    if (offset < 0 || offset >= codeSize) {
      throw new JaninoRuntimeException(functionName + ": Offset out of range");
    }
    int css=stackSizes[offset];
    if (css == stackSize)     return;
    if (css == CodeContext.INVALID_OFFSET)     throw new JaninoRuntimeException(functionName + ": Invalid offset");
    if (css != CodeContext.UNEXAMINED) {
      if (CodeContext.DEBUG) {
        System.err.println(functionName + ": Operand stack inconsistent at offset " + offset+ ": Previous size "+ css+ ", now "+ stackSize);
        return;
      }
 else {
        throw new JaninoRuntimeException(functionName + ": Operand stack inconsistent at offset " + offset+ ": Previous size "+ css+ ", now "+ stackSize);
      }
    }
    stackSizes[offset]=stackSize;
    byte opcode=code[offset];
    int operandOffset=offset + 1;
    short props;
    if (opcode == Opcode.WIDE) {
      opcode=code[operandOffset++];
      props=Opcode.WIDE_OPCODE_PROPERTIES[0xff & opcode];
    }
 else {
      props=Opcode.OPCODE_PROPERTIES[0xff & opcode];
    }
    if (props == Opcode.INVALID_OPCODE) {
      throw new JaninoRuntimeException(functionName + ": Invalid opcode " + (0xff & opcode)+ " at offset "+ offset);
    }
switch (props & Opcode.SD_MASK) {
case Opcode.SD_M4:
case Opcode.SD_M3:
case Opcode.SD_M2:
case Opcode.SD_M1:
case Opcode.SD_P0:
case Opcode.SD_P1:
case Opcode.SD_P2:
      stackSize+=(props & Opcode.SD_MASK) - Opcode.SD_P0;
    break;
case Opcode.SD_0:
  stackSize=0;
break;
case Opcode.SD_GETFIELD:
--stackSize;
case Opcode.SD_GETSTATIC:
stackSize+=this.determineFieldSize((short)(CodeContext.extract16BitValue(0,operandOffset,code)));
break;
case Opcode.SD_PUTFIELD:
--stackSize;
case Opcode.SD_PUTSTATIC:
stackSize-=this.determineFieldSize((short)(CodeContext.extract16BitValue(0,operandOffset,code)));
break;
case Opcode.SD_INVOKEVIRTUAL:
case Opcode.SD_INVOKESPECIAL:
case Opcode.SD_INVOKEINTERFACE:
--stackSize;
case Opcode.SD_INVOKESTATIC:
stackSize-=this.determineArgumentsSize((short)(CodeContext.extract16BitValue(0,operandOffset,code)));
break;
case Opcode.SD_MULTIANEWARRAY:
stackSize-=code[operandOffset + 2] - 1;
break;
default :
throw new JaninoRuntimeException(functionName + ": Invalid stack delta");
}
if (stackSize < 0) {
String msg=(this.classFile.getThisClassName() + '.' + functionName+ ": Operand stack underrun at offset "+ offset);
if (CodeContext.DEBUG) {
System.err.println(msg);
return;
}
 else {
throw new JaninoRuntimeException(msg);
}
}
if (stackSize > CodeContext.MAX_STACK_SIZE) {
String msg=(this.classFile.getThisClassName() + '.' + functionName+ ": Operand stack overflow at offset "+ offset);
if (CodeContext.DEBUG) {
System.err.println(msg);
return;
}
 else {
throw new JaninoRuntimeException(msg);
}
}
switch (props & Opcode.OP1_MASK) {
case 0:
;
break;
case Opcode.OP1_SB:
case Opcode.OP1_UB:
case Opcode.OP1_CP1:
case Opcode.OP1_LV1:
++operandOffset;
break;
case Opcode.OP1_SS:
case Opcode.OP1_CP2:
case Opcode.OP1_LV2:
operandOffset+=2;
break;
case Opcode.OP1_BO2:
if (CodeContext.DEBUG) {
System.out.println("Offset = " + offset);
System.out.println("Operand offset = " + operandOffset);
System.out.println(code[operandOffset]);
System.out.println(code[operandOffset + 1]);
}
this.flowAnalysis(functionName,code,codeSize,CodeContext.extract16BitValue(offset,operandOffset,code),stackSize,stackSizes);
operandOffset+=2;
break;
case Opcode.OP1_JSR:
if (CodeContext.DEBUG) {
System.out.println("Offset = " + offset);
System.out.println("Operand offset = " + operandOffset);
System.out.println(code[operandOffset]);
System.out.println(code[operandOffset + 1]);
}
int targetOffset=CodeContext.extract16BitValue(offset,operandOffset,code);
operandOffset+=2;
if (stackSizes[targetOffset] == CodeContext.UNEXAMINED) {
this.flowAnalysis(functionName,code,codeSize,targetOffset,(short)(stackSize + 1),stackSizes);
}
break;
case Opcode.OP1_BO4:
this.flowAnalysis(functionName,code,codeSize,CodeContext.extract32BitValue(offset,operandOffset,code),stackSize,stackSizes);
operandOffset+=4;
break;
case Opcode.OP1_LOOKUPSWITCH:
while ((operandOffset & 3) != 0) ++operandOffset;
this.flowAnalysis(functionName,code,codeSize,CodeContext.extract32BitValue(offset,operandOffset,code),stackSize,stackSizes);
operandOffset+=4;
int npairs=CodeContext.extract32BitValue(0,operandOffset,code);
operandOffset+=4;
for (int i=0; i < npairs; ++i) {
operandOffset+=4;
this.flowAnalysis(functionName,code,codeSize,CodeContext.extract32BitValue(offset,operandOffset,code),stackSize,stackSizes);
operandOffset+=4;
}
break;
case Opcode.OP1_TABLESWITCH:
while ((operandOffset & 3) != 0) ++operandOffset;
this.flowAnalysis(functionName,code,codeSize,CodeContext.extract32BitValue(offset,operandOffset,code),stackSize,stackSizes);
operandOffset+=4;
int low=CodeContext.extract32BitValue(offset,operandOffset,code);
operandOffset+=4;
int hi=CodeContext.extract32BitValue(offset,operandOffset,code);
operandOffset+=4;
for (int i=low; i <= hi; ++i) {
this.flowAnalysis(functionName,code,codeSize,CodeContext.extract32BitValue(offset,operandOffset,code),stackSize,stackSizes);
operandOffset+=4;
}
break;
default :
throw new JaninoRuntimeException(functionName + ": Invalid OP1");
}
switch (props & Opcode.OP2_MASK) {
case 0:
;
break;
case Opcode.OP2_SB:
++operandOffset;
break;
case Opcode.OP2_SS:
operandOffset+=2;
break;
default :
throw new JaninoRuntimeException(functionName + ": Invalid OP2");
}
switch (props & Opcode.OP3_MASK) {
case 0:
;
break;
case Opcode.OP3_SB:
++operandOffset;
break;
default :
throw new JaninoRuntimeException(functionName + ": Invalid OP3");
}
Arrays.fill(stackSizes,offset + 1,operandOffset,CodeContext.INVALID_OFFSET);
if ((props & Opcode.NO_FALLTHROUGH) != 0) return;
offset=operandOffset;
}
}
