{
  int count=parsers.length;
  if (this.optionalMethodNames != null && this.optionalMethodNames.length != count) {
    throw new IllegalStateException("methodName count");
  }
  if (this.optionalParameterNames != null && this.optionalParameterNames.length != count) {
    throw new IllegalStateException("parameterNames count");
  }
  if (this.optionalParameterTypes != null && this.optionalParameterTypes.length != count) {
    throw new IllegalStateException("parameterTypes count");
  }
  if (this.optionalOverrideMethod != null && this.optionalOverrideMethod.length != count) {
    throw new IllegalStateException("overrideMethod count");
  }
  if (this.optionalReturnTypes != null && this.optionalReturnTypes.length != count) {
    throw new IllegalStateException("returnTypes count");
  }
  if (this.optionalStaticMethod != null && this.optionalStaticMethod.length != count) {
    throw new IllegalStateException("staticMethod count");
  }
  if (this.optionalThrownExceptions != null && this.optionalThrownExceptions.length != count) {
    throw new IllegalStateException("thrownExceptions count");
  }
  Java.CompilationUnit compilationUnit=this.makeCompilationUnit(count == 1 ? parsers[0] : null);
  Java.ClassDeclaration cd=this.addPackageMemberClassDeclaration(parsers[0].location(),compilationUnit);
  String[] methodNames;
  if (this.optionalMethodNames == null) {
    methodNames=new String[count];
    for (int i=0; i < count; ++i)     methodNames[i]="eval" + i;
  }
 else {
    methodNames=this.optionalMethodNames;
  }
  for (int i=0; i < count; ++i) {
    Parser parser=parsers[i];
    List<Java.BlockStatement> statements=this.makeStatements(i,parser);
    boolean staticMethod=this.optionalStaticMethod == null || this.optionalStaticMethod[i];
    boolean overrideMethod=this.optionalOverrideMethod != null && this.optionalOverrideMethod[i];
    Class returnType=(this.optionalReturnTypes == null ? this.getDefaultReturnType() : this.optionalReturnTypes[i]);
    String[] parameterNames=(this.optionalParameterNames == null ? new String[0] : this.optionalParameterNames[i]);
    Class[] parameterTypes=(this.optionalParameterTypes == null ? new Class[0] : this.optionalParameterTypes[i]);
    Class[] thrownExceptions=(this.optionalThrownExceptions == null ? new Class[0] : this.optionalThrownExceptions[i]);
    Location loc=parser.location();
    cd.addDeclaredMethod(this.makeMethodDeclaration(loc,(overrideMethod ? new Java.Annotation[]{new Java.MarkerAnnotation(this.classToType(loc,Override.class))} : new Java.Annotation[0]),staticMethod,returnType,methodNames[i],parameterTypes,parameterNames,thrownExceptions,statements));
  }
  Class c=this.compileToClass(compilationUnit);
  this.result=new Method[count];
  if (count <= 10) {
    for (int i=0; i < count; ++i) {
      try {
        this.result[i]=c.getDeclaredMethod(methodNames[i],this.optionalParameterTypes == null ? new Class[0] : this.optionalParameterTypes[i]);
      }
 catch (      NoSuchMethodException ex) {
        throw new JaninoRuntimeException(("SNO: Loaded class does not declare method \"" + methodNames[i] + "\""),ex);
      }
    }
  }
 else {
class MethodWrapper {
      private final String name;
      private final Class[] parameterTypes;
      MethodWrapper(      String name,      Class[] parameterTypes){
        this.name=name;
        this.parameterTypes=parameterTypes;
      }
      @Override public boolean equals(      Object o){
        if (!(o instanceof MethodWrapper))         return false;
        MethodWrapper that=(MethodWrapper)o;
        if (!this.name.equals(that.name))         return false;
        int cnt=this.parameterTypes.length;
        if (cnt != that.parameterTypes.length)         return false;
        for (int i=0; i < cnt; ++i) {
          if (!this.parameterTypes[i].equals(that.parameterTypes[i]))           return false;
        }
        return true;
      }
      @Override public int hashCode(){
        int hc=this.name.hashCode();
        for (        Class parameterType : this.parameterTypes)         hc^=parameterType.hashCode();
        return hc;
      }
    }
    Method[] ma=c.getDeclaredMethods();
    Map<MethodWrapper,Method> dms=new HashMap(2 * count);
    for (    Method m : ma)     dms.put(new MethodWrapper(m.getName(),m.getParameterTypes()),m);
    for (int i=0; i < count; ++i) {
      Method m=(Method)dms.get(new MethodWrapper(methodNames[i],this.optionalParameterTypes == null ? new Class[0] : this.optionalParameterTypes[i]));
      if (m == null) {
        throw new JaninoRuntimeException("SNO: Loaded class does not declare method \"" + methodNames[i] + "\"");
      }
      this.result[i]=m;
    }
  }
}
